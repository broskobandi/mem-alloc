#include <test.h>
#include "mem_alloc_private.h"

TEST_INIT;

void test_use_mmap() {
	const size_t SIZE = ARENA_SIZE * 2;
	size_t total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	void *mem = use_mmap(total_size);
	ASSERT(mem);
	ASSERT(PTR(mem)->mem == mem);
	ASSERT(PTR(mem)->total_size == ROUNDUP(total_size, (size_t)getpagesize()));
	ASSERT(!munmap(PTR(mem), PTR(mem)->total_size));
}

void test_use_arena() {
	arena_t arena = {0};
	const size_t SIZE = ARENA_SIZE / 32;
	size_t total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	void *mem = use_arena(total_size, &arena);
	void *mem2 = use_arena(total_size, &arena);
	
	ASSERT(PTR(mem)->total_size == total_size);
	ASSERT(PTR(mem)->is_valid);
	ASSERT(!PTR(mem)->is_mmap);
	ASSERT(!PTR(mem)->is_mmap);
	ASSERT(!PTR(mem)->next_free);
	ASSERT(!PTR(mem)->prev_free);
	ASSERT(!PTR(mem)->prev);

	ASSERT(PTR(mem)->next == PTR(mem2));
	ASSERT(PTR(mem2)->prev == PTR(mem));
}

void test_add_to_free_list() {
	arena_t arena = {0};
	const size_t SIZE = ARENA_SIZE / 32;
	size_t total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	void *mem = use_arena(total_size, &arena);
	void *mem2 = use_arena(total_size, &arena);
	add_to_free_list(PTR(mem), &arena);
	ASSERT(!PTR(mem)->is_valid);
	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem));
	add_to_free_list(PTR(mem2), &arena);
	ASSERT(!PTR(mem2)->is_valid);
	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem2));
	ASSERT(PTR(mem)->next_free == PTR(mem2));
	ASSERT(PTR(mem2)->prev_free == PTR(mem));
}

void test_mem_alloc() {
	reset_global_arena();

	// Use mmap
	const size_t LARGE_SIZE = ARENA_SIZE * 2;
	size_t total_size = MEM_OFFSET + ROUNDUP(LARGE_SIZE, MIN_ALLOC);
	size_t total_size_internal = ROUNDUP(total_size, (size_t)getpagesize());
	void *mem = mem_alloc(LARGE_SIZE);
	ASSERT(PTR(mem)->is_mmap);
	ASSERT(PTR(mem)->total_size == total_size_internal);

	// Use arena
	arena_t *arena = global_arena();
	const size_t SIZE = ARENA_SIZE / 32;
	total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	mem = mem_alloc(SIZE);
	ASSERT(mem);
	ASSERT(PTR(mem)->total_size == total_size);
	ASSERT(arena->ptrs_tail == PTR(mem));

	// Use free list
	add_to_free_list(PTR(mem), arena);
	void *mem2 = mem_alloc(SIZE);
	ASSERT(mem2 == mem);
	ASSERT(!arena->free_ptr_tails[SIZE_CLASS(SIZE)]);
}

void test_remove_from_free_list() {
	arena_t arena = {0};
	const size_t SIZE = ARENA_SIZE / 32;
	size_t total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	void *mem = use_arena(total_size, &arena);
	void *mem2 = use_arena(total_size, &arena);
	void *mem3 = use_arena(total_size, &arena);

	add_to_free_list(PTR(mem), &arena);
	add_to_free_list(PTR(mem2), &arena);
	add_to_free_list(PTR(mem3), &arena);
	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem3));

	remove_from_free_list(PTR(mem2), &arena);
	ASSERT(PTR(mem)->next_free == PTR(mem3));
	ASSERT(PTR(mem3)->prev_free == PTR(mem));
	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem3));

	remove_from_free_list(PTR(mem3), &arena);
	ASSERT(!PTR(mem)->next_free);
	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem));

	remove_from_free_list(PTR(mem), &arena);
	ASSERT(!arena.free_ptr_tails[SIZE_CLASS(SIZE)]);
}

void test_merge_free_ptrs() {
	arena_t arena = {0};
	const size_t SIZE = ARENA_SIZE / 32;
	size_t total_size = MEM_OFFSET + ROUNDUP(SIZE, MIN_ALLOC);
	void *mem = use_arena(total_size, &arena);
	void *mem2 = use_arena(total_size, &arena);
	void *mem3 = use_arena(total_size, &arena);
	void *mem4 = use_arena(total_size, &arena);

	add_to_free_list(PTR(mem), &arena);
	add_to_free_list(PTR(mem2), &arena);
	add_to_free_list(PTR(mem3), &arena);

	ASSERT(arena.free_ptr_tails[SIZE_CLASS(SIZE)] == PTR(mem3));

	merge_free_ptrs(PTR(mem2), &arena);
	ASSERT(PTR(mem)->next == PTR(mem4));
	ASSERT(PTR(mem)->total_size == total_size * 3);
}

void test_mem_free() {
	// munmap
	void *mem = mem_alloc(ARENA_SIZE * 2);
	ASSERT(!mem_free(mem));

	// Adjust offset
	reset_global_arena();
	arena_t *arena = global_arena();
	mem = mem_alloc(ARENA_SIZE / 32);
	ASSERT(arena->offset == PTR(mem)->total_size);
	ASSERT(mem_free(mem) == 1);
	ASSERT(!arena->offset);
	ASSERT(!arena->ptrs_tail);

	// add to free list
	mem = mem_alloc(ARENA_SIZE / 32);
	void *mem2 = mem_alloc(ARENA_SIZE / 32);
	ASSERT(arena->offset == PTR(mem2)->total_size * 2);
	ASSERT(mem_free(mem) == 2);
	
}

void test_alloc_struct_member() {
	reset_global_arena();

	typedef struct obj {
		void *data;
	} obj_t;

	obj_t *obj = mem_alloc(sizeof(obj_t));
	ASSERT(obj);

	obj->data =  mem_alloc(1024);
	ASSERT(obj->data);

	ASSERT(mem_free(obj->data) == 1);
	ASSERT(mem_free(obj) == 1);
}

void test_mem_realloc() {
	reset_global_arena();

	// return same pointer
	//// arena
	void *mem = mem_alloc(MIN_ALLOC - MIN_ALLOC / 2);
	size_t old_total_size = PTR(mem)->total_size;
	void *new_mem = mem_realloc(mem, MIN_ALLOC);
	size_t new_total_size = PTR(mem)->total_size;
	ASSERT(new_mem == mem);
	ASSERT(old_total_size == new_total_size);
	mem_free(mem);

	//// mmap
	mem = mem_alloc(ARENA_SIZE + MIN_ALLOC);
	old_total_size = PTR(mem)->total_size;
	new_mem = mem_realloc(mem, ARENA_SIZE + MIN_ALLOC * 2);
	new_total_size = PTR(mem)->total_size;
	ASSERT(mem == new_mem);
	ASSERT(old_total_size == new_total_size);
	mem_free(mem);

	// return same pointer with merge
	mem = mem_alloc(ARENA_SIZE / 32);
	void *mem2 = mem_alloc(ARENA_SIZE / 32);
	void *mem3 = mem_alloc(ARENA_SIZE / 32);
	mem_free(mem2);
	ASSERT(mem3);
	new_mem = mem_realloc(mem, ARENA_SIZE / 32 * 2);
	ASSERT(new_mem == mem);
	old_total_size = MEM_OFFSET + ROUNDUP(ARENA_SIZE / 32 , MIN_ALLOC);
	new_total_size = old_total_size * 2;

	printf("%lu\n", old_total_size);
	printf("%lu\n", new_total_size);
	//ASSERT(PTR(mem)->total_size == total_size);

}

int main(void) {
	test_use_mmap();
	test_use_arena();
	test_add_to_free_list();
	test_mem_alloc();
	test_remove_from_free_list();
	test_merge_free_ptrs();
	test_mem_free();
	test_alloc_struct_member();
	test_mem_realloc();
	
	test_print_results();
	return 0;
}
